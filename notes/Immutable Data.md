# Immutable Data

Immutable 使用了的结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点则进行共享

优点：
* Immutable 降低了 Mutable 带来的复杂度
* 节省内存 使用了结构共享，会尽量的复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收
* Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 因为每次数据都是不一样的，只要把这些数据放到一个数组里面储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能
* 并发安全，就不用害怕处理各种数据不一致的问题，因为使用了immutable后，数据天生是不可变的，并发锁也是不需要了的
* 拥抱FP，Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。


缺点：
* 需要学习新的 API
*  增加了资源文件大小
*  容易与原生对象混淆 
    ```
    Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get('key') 而不是 map.key，array.get(0) 而不是 array[0]。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。

当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。

下面给出一些办法来避免类似问题发生：

使用 Flow 或 TypeScript 这类有静态类型检查的工具
约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。
使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。
```

    

