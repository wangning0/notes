# HTTP与HTTPS

## HTTPS的理解
HTTP协议传输的数据是未加密的，都是明文

SSL(Server Sockets Layer)协议用于对HTTP协议传输的数据进行加密，从而诞生了HTTPS

对SSL3.0的升级，出现了TLS(Transport layer security)

**HTTPS的工作原理**
传输数据之前需要浏览器和服务端进行一次握手，在握手过程中将确定双方加密传输数据的password message

对称算法
> AES RC4 3DES

非对称算法
> RSA DSA/DSS

HASH算法
> MD5 SHA1 SHA256

**过程**

* 浏览器将自己支持的加密规则发送给网站
* server从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发送回浏览器（网站地址、公钥、颁发机构）
* 浏览器获得了服务器的证书之后

    * 验证合法性(合法则出现小锁头)
    * 浏览器生成一串随机数的密码，并用证书中提供的公钥加密
    * 使用约定好的HASH计算握手信息，使用生成的随机数对信息加密，在发送给服务器
    
* 服务器接受浏览器的操作后

    * 使用私钥进行解密，并验证HASH是否与浏览器发送来的一致
    * 使用密码加密一段握手信息，发送给浏览器
    
* 浏览器解密并计算握手信息的HASH，如果与服务器发来的HASH一致，则握手结束，之后由B生成的随机密码并利用对称算法加密  


## HTTP2与HTTP1.x的区别
* HTTP2利用二进制格式传输数据，而非1.x里的文本格式，二进制格式在协议的解析和优化扩展上带来更多的优势和可能(没有冗余字段，传输搞笑，方便解析（固定长度，并且可以直接比较字节），自然加密，难理解性，对数据安全有一定的要求)
* 对消息头采用HPACK进行压缩传输，节省网络流量，而HTTP1.x每次请求都会携带大量冗余信息
* 多路复用，所有请求通过一个TCP完成，HTTP1.x虽然通过pipeline也能并发，但是多个请求之间的响应是阻塞的
* server push 服务端更快的把资源推送到客户端


## HTTP1.1与1.0的区别
* HTTP1.1支持长连接，1.0只能短连接
* 增加了cache-control头域


## websocket
websocket的基本步骤

* 先进行TCP连接
* 客户端发送握手
* 服务端响应握手
* 握手完毕后，可以相互传输数据
* 连接结束，关闭控制桢并断开TCP

## DNS劫持
一般而言，用户上网的DNS服务器都是运营商分配的，所以在这个节点上，运营商可以为所欲为。例如，访问a网站，正常DNS应该返回a网站的ip，而DNS劫持后，会返回一个运营商的中间服务器ip，访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，在网页中再通过iframe打开用户原来访问的地址

## HTTP劫持

在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理，后续做法往往2种，一种是类似DNS劫持返回302让用户让浏览器跳转到另外的地址，还有一种就是在服务器返回的html数据中插入js或dom节点

[解决办法](http://www.cnblogs.com/kenkofox/p/4919668.html)

## HTTPS解决的问题
* 信任主机的问题。采用https 的server 必须从CA 申请一个用于证明服务器用途类型的证书. 改证书只有用于对应的server 的时候，客户度才信任次主机。所以目前所有的银行系统网站,关键部分应用都是https 的。客户通过信任该证书，从而信任了该主机。其实这样做效率很低，但是银行更侧重安全。这一点对我们没有任何意义，我们的server采用的证书不管自己issue 还是从公众的地方issue，客户端都是自己人，所以我们也就肯定信任该server。
* 通讯过程中的数据的泄密和被窜改



## Web页面请求的历程

1. 输入URL
2. Web浏览器通过生成一个TCP套接字开始了该过程，套接字用于像域名所在的服务器发送HTTP请求
3. 为了生成该套接字，于是使用DNS协议的将域名转化为IP地址的服务
4. 操作系统因此生成一个DNS查询报文，将字符串域名放入DNS报文的问题段中


