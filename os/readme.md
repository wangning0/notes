# 操作系统

> 操作系统是一组控制和管理计算机硬件和软件资源，合理的对各类作业进行调度以及方便用户使用的程序的集合


**操作系统的基本特征**
并发是最重要的特征，其他特征基本都以并发为前提

* 并发

    ```
    并行性是指两个或多个事件在同一时刻发生
    并发性是指两个或多个事件在同一时间间隔发生
    
    任务共行，从微观上来说
        单处理系统中的任务并发
        多处理系统中的任务并行
    ```    
    
* 共享

    ```
    系统中的资源可供内存中多个并发执行的进程共同使用
    临界资源： 在一段时间内只允许一个进程访问的资源
    互斥共享方式： 系统中的临界资源可以提供给多个进程使用，但一次仅能允许一个进程使用
    
    同时访问方式，从微观上来说，资源共享是指多个任务互斥地使用系统中的某个资源(如磁盘)
    ```
* 虚拟

    ```
    通过某种技术把一个物理实体变味若干个逻辑上的对应物
    虚拟处理机：分时实现
    虚拟设备：SPOOLING技术
    虚拟存储器：虚拟存储管理实现
    ```
* 不确定性

    ```
    同样的程序，同样的输入，未必同样的输出
    异步性： 是指进程已异步的方式执行，进程是已不可预知的速度向前推进
    ```
    
**进程**
    
* 进程控制

     ```
     进程控制的主要功能是为作业创建进程、撤销已结束的进程以及控制进程在运行过程中的状态转换
     ```
* 进程同步
    
    ```
    进程同步的主要任务是为了多个进程的运行进行协调
    两种方式：
        - 进程互斥方式，这是指进（线）程在对临界资源进行访问时
        - 进程同步方式，指进程相互合作完成共同的任务时，进程之间的协调
    ```
        
* 进程通信（IPC） 
* 调度

    ```
    在OS中作业／进程需要调度后才能执行完成
    ```
    
**内存**

* 内存分配

    ```
    分配方式：
        - 静态分配
        - 动态分配
    ```
* 内存保护

    ```
    首要任务是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰
    
    内部保护机制：设置两个界限寄存器，越界检查由硬件实现
    
    ```
* 地址映射

    ```
    地址空间：目标程序或装入程序限定的空间，称为“地址空间”
    内存空间：由内存中的一系列但愿所限定的地址范围称为“内存空间”，其中的地址称为物理地址
    地址映射：运行时，将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址，称为地址映射
    ```
* 内存扩充

    ```
    虚拟内存技术
    
    内存扩充机制：
        - 请求调入功能，程序运行过程中，若所需的程序和数据尚未装入内存，可由OS从磁盘中将所需部分掉入内存，继续运行
        - 置换功能，将内存中的一部分暂时不用的程序和数据调出道磁盘上，然后再将所需掉入的部分装入内存
    ```

## 进程管理

* 进程

    ```
    一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程，进程描述了动态执行过程
    
    进程的特征：
        - 动态性
        - 独立性
        - 并发性
        - 异步性
        - 结构化 （进程=代码段+数据段+PCB）
    ```
* 进程是动态的，程序是静态的，程序是有序代码的集合，进程是暂时的，程序是永久的，进程是一个状态变化的过程，程序可长久保存，进程的组成包括程序，数据和PCB，进程是资源申请和系统调度的基本单位
* 进程的特征和状态

    ```
    进程的三种基本状态：
        - 就绪态(ready) 一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态，当调度給其CPU时，立即可以运行，位于就绪队列中
        - 执行态(running) 进程占有了包括CPU在内的全部资源，并在CPU上运行
        - 等待态/阻塞态(waiting/bolcked) 进程因等待某种事件的发生而暂时不能运行的状态，即使CPU空闲，该进程也不可运行，位于等待队列中
    ```
    ![](https://github.com/wangning0/notes/blob/master/os/images/1.png)
    
    ```
    五状态：
        - 新建状态 
            - os已完成为创建一进程所必要的工作
                - 构造了进程标志符
            - 但还没有允许执行该进程
                - os所需的关于该进程的信息保存在主存的进程表中，单进程自身还没有进入主存，也没有为这个程序相关的数据分配空间，程序留在辅存中
        - 退出状态
            - 不再有执行资格
            - 表格和其他信息暂时由辅助程序保留
        - 就绪态
        - 执行态
        - 阻塞态
    ```
    
    ```
    交换：
        - 挂起 把一个进程从内存转到外存
        - 激活 把一个进程从外村转到内存
    交换时I／O操作，费时间
    ```
    
    ![](https://github.com/wangning0/notes/blob/master/os/images/2.png)
    
    ```
    双挂起
        - 就绪 进程在内存且可立即进入运行状态
        - 阻塞 进程在内存，等待事件的出现
        - 阻塞／挂起 进程在外存  等待事件的出现
        - 就绪／挂起 进程在外存 但只要进入内存 即可执行
    ```
    
    ![](https://github.com/wangning0/notes/blob/master/os/images/3.png)


* 操作系统对进程的控制

    ```
    操作系统内核
        - 一些与硬件紧密相关的模块或运行频率很高的模块，公用基本操作模块等常驻内存，便于提高操作系统运行效能的软件

    内核的功能
        - 进程管理 创建、撤销、调度、控制
        - 存储管理 分配或回收空间、虚拟存储管理
        - I/O设备管理 设备、通道的分配和回收、设备的管理、虚拟设备的实现
        - 中断处理 操作系统的充要活动都依赖于中断
    ```
    
* 进程控制块

    |PCB  | | 
    | :--  |  :--  | 
    | pid  | 进程标志符 |
    |  进程状态 | 指明进程当前的状态 |
    |  现场    | |
    |  优先级    | 进程优先级 |
    | 阻塞原因     | 由执行状态转变成阻塞状态所等待发生的事件 |
    |  程序地址    | 进程的程序和数据所在的内存或外村地址 |
    |  同步机制    | 实现进程同步和进程通信时必须的机制 | 
    | 资源清单    | 进程所需的全部资源以及分配到该进程的资源的清单 |
    | 链接指针  | |

* 进程控制块的组织方式
    
    * 链接方式
    * 索引方式

* 进程组织

    ```
    进程树
        - 描述了进程的家族关系
        - 子进程可继承父进程的资源
        - 父进程的撤销会撤销全部子进程
        - 根进程
        - 孤儿进程的托管
    ```
    
* 进程的创建

    * 用户登录
    * 作业调度
    * 提供服务
    * 应用请求

    ```
    进程的创建
        - 申请空白PCB
        - 为新进程分配资源（内存、文件等）
        - 初始化PCB数据结构
        - 将新进程插入就绪队列

    创建新进程后
        - 父进程与子进程并发执行
        - 父进程等待，直到某个或者全部子进程执行完毕

    ```
    
* 进程控制函数

    ```
    fork  创建新进程
        - 在调用fork之后，父子进程俊仔下一条语句上继续执行
        - 子进程中返回的pid为0
        - 父进程中返回的pid是创建的子进程pid
    ```
    
    ```
    fork（）两个关键点
        - 运行顺序
            - 父子进程的运行是无关的，运行顺序不固定
            - 若要求父子进程运行顺序一定，要用到IPC
        - 数据共享
            - 出了子进程标志符合PCB结构中的某些参数不同，子进程是父进程的精确复制
    ```
    
    ```
    exec() 执行一个文件的调用
        - 通过exec() 调用族，加载新的程序文件
        - 子进程可拥有自己的可执行代码，即用一个新进程覆盖调用进程
        - 在大多数程序中，系统调用fork和exec是结合在一起的，父进程生成一个子进程，然后通过调用exec覆盖该子进程
    ```
* 进程的终止

    ```
    引起进程终止的事件
        - 正常结束 exit halt logoff
        - 异常结束
            - 无可用存储器
            - 越界
            - 保护错误
            - 算术错误
            - I/O失败
            - 无效指令
            - 特权指令
        - 外界干预
            - kill进程
            - 父进程终止
            - 父进程请求

    进程的终止过程
        - 检索PCB，检查进程状态
        - 执行态 ===> 终止
        - 有无子孙需终止
        - 归还资源给父进程／系统
        - 从PCB队列中移出PCB
    ```
* 进程的两个特点

    * 资源所有权，一个进程包括一个保存进程映像的虚地址空间，并且不时地被分配给对资源的控制或所有权
    * 调度／执行，一个具有执行状态和调度优先级的进程是一个被操作系统调度并分发的实体

    ```
    为了区分这两个特点，调度并分发派的部门被称为线程／轻量级进程，而资源所有权被称为进程
    ```

* 线程的优势

    * 减少并发执行时的时空开销
    * 线程是系统独立调度的基本单位，基本不拥有系统资源，只有少量资源(PC 寄存器 栈),共享其所属进程所拥有的全部资源

* 进程与线程

    ![](https://github.com/wangning0/notes/blob/master/os/images/4.png)
    
* 线程状态

    * 执行状态、阻塞状态、就绪状态
    * 在线程切换时保存的线程信息

        * 一个执行栈
        * 每个线程静态存储局部变量
        * 对存储器和其进程资源的访问
    * 派生， 当产生一个新进程时，同时也为该进程派生了一个线程，随后可以在同一个进程中派生另一个线程，新线程放在就绪队列中
    * 结束，线程完成时，其寄存器信息和栈都被释放
    * 就绪
    * 运行
    * 阻塞，当线程需要等待一个事件时，他将阻塞，处理器转而执行另一个就绪线程

* 线程分类

    * 内核级线程，每个线程在内核看来都是一个进程

        ```
        内核级线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，其创建、撤销和切换等都是依靠内核实现
        内核为每一个内核线程设置了一个线程控制块，根据该控制块感知线程的存在，加以控制
        ```
    * 用户级线程，内核无法感知，用户自己控制

        ```
        用户级线程的创建、撤销、线程之间的同步与通信等功能，都无须利用系统调用来实现
        用户级线程的切换，速度快，不需要内核的支持
        线程控制块设置在用户空间，节省系统开销
        当引起进程阻塞时，会削弱进程中的线程的并发性
        ```
    ```
    内核线程和用户线程不同：
        - 调度开销前者大，相当于进程切换
        - 并发效率，用户线程某一个线程阻塞，由于内核不知道这些进程的存在，因此将进程阻塞，内核线程中某一个线程阻塞，则阻塞改线程，进程仍可运行
        - 执行时间，用户级线程以进程为单位平均分配时间，对线程间并发执行不利，内核级线程以线程为单位分配时间
    ```

## 处理机调度

> 处理机是最重要的计算机资源，提高处理机的利用率及改善系统性能(吞吐量、响应时间),在很大程度上取决于进程调度性能的好坏

* 调度的目标

    * 提高处理机的利用率
    * 提高系统吞吐量
    * 尽量减少进程的响应时间
    * 防止进程长期得不到运行

* 调度的方式

    ```
    低级调度
        - 短程调度
        - 进程调度
    中级调度 为提高系统吞吐量和内存利用率而引入的内外存交换功能
        - 中程调度
    高级调度  将外存作业掉入内存，创建PCB等，插入就绪队列
        - 长程调度
        - 作业调度
        - 接纳调度
    ```
* 进程调度算法基本类型

    * 非抢占 就绪进程不可以从运行进程中抢占CPU

        ```
        一旦进程处于运行状态，直到终止或者阻塞，才释放CPU
        ```
    * 抢占 就绪进程可以从运行进程中抢占CPU

        ```
        允许调度程序根据某种策略暂停当前运行的进程，将其转移到就绪状态，并选择另一个进程执行
        新进程到达时，中断的发生，阻塞进程置为就绪态
        ```
* 调度的原则

    * 面向用户的原则

        * 周转时间
        * 响应时间
        * 截止时间
        * 优先级
    
    * 面向系统的原则

        * 吞吐量
        * 利用率
        * 公平性
        * 优先级

* 调度算法

    * 先来先服务 FCFS
    
        ```
        当每个进程就绪后，它加入就绪队列(队尾)
        当正在运行的进程停止执行时，选择在就绪队列中存在时间最长的进程运行(队首)
        
        评价
        非抢占调度
        对长进程有利，不利于短进程
        适合CPU繁忙型进程，不适合I/O繁忙型进程
        不能直接用于分时系统
        和其他调度算法综合使用
        ```
    * 最短作业优先 SJF

        ```
        非剥夺，当前进程结束后，选择所需处理时间最短的进程
        如果两个进程剩余时间相同，则使用FCFS来调度
        
        评价
            - 有利于短进程，提高了平均周转时间
            - 长进程可能被饿死
            - 需要知道或估计每个进程的处理时间
        ```

    * 轮转调度RR(Round Robin)

        ```
        时间片调度： 以一定的时间间隔周期性产生时钟中断，当前正在运行的进程被置于就绪队列尾，然后基于FCFS选择下一个就绪进程运行
        
        时间片的长度从几ms~几百ms
        
        时间片长度变化影响较大
            - 过长，退化成FCFS
            - 过短，用户的一次请求需要多个时间片才能处理完，上下文切换次数增加
        ```
        
    * 最短剩余时间调度SRT

        ```
        原理
            - 对SJF增加了剥夺机制
            - 选择预期剩余时间最短的进程，当一个新进程加入就绪队列时，他肯呢个比当前运行的进程具有更短的剩余时间
        ```
    * 基于优先级的调度算法

        ```
        每个进程都有一个优先级，调度程序选择具有较高优先级的进程
        ```
    * 高响应比优先算法(HRRN)

        ```
        非抢占式
        响应比R = 周转时间／服务时间 = （等待时间+服务时间）／服务时间
        ```
        
    * 多级队列调度算法，将就绪队列分为多个独立队列，进程所属的队列固定，通过对各队列的区别对待，达到一个综合的调度目标

## 进程并发控制： 互斥与同步

* 进程间的制约关系

    * 间接制约 资源共享 -> 互斥
    * 直接制约 进程合作 -> 同步

* 临界资源，一次只允许一个进程访问的资源
* 临界区， 进程中访问临界资源的代码段
* 同步的解决策略

    * 软件
    * 硬件
    * 信号量

        ```
        多进程通过信号传递协调工作，根据信号指示停止执行或者向前推进
        
        信号： 信号量(s)
        
        原语
            - wait(s) 等待信号，并占有资源
            - signal(s) 释放资源，并激发信号
        ```
    * 管程
    * 消息传递

## 进程并发控制： 信号量的应用

* 信号量类型

    * 资源信号量
    * 互斥信号量

* PV操作，P表示通过的意思，V表示释放的意思
* 读者／写者问题

    ```
    三个角色
        - 一个共享的数据去
        - Reader 制度去这个数据区的进程
        - Writer 只往数据区中写数据的进程
    三个条件
        - 多个Reader 可同时读数据区
        - 一次只有一个Writer可以往数据区写
        - 数据区不允许同时读写

    读者优先
        如有读者正在读数据，则允许多个读者同时进入读数据，只有所有读者退出，在允许写者进入写数据
    
    写者优先
        如果写者正在写，那么后续的写者申请优先于心的读者进入
    ```
    
## 进程间通信

> IPC 是指进程之间的信息交换

* 进程通信分为两类

    * 低级通信： 以信号量为通信工具，交换的信息量少
    * 高级通信：操作系统所提供的一组通信命令，高效地传送大量数据
    
        ```
        共享存储
        消息传递／消息队列
        管道
        套接字
        信号
        内存映射文件
        ```
## 死锁

> 多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，他们都将无法向前推进

* 产生死锁的原因

    * 资源不足导致的资源竞争
    * 并发执行的顺序不当

* 死锁的充要条件

    * 互斥,进程对所分配到的资源进行排他性使用
    * 占有且等待，进程已经占有了至少一个资源，又提出了新的资源要求，且该资源被其他进程占有
    * 非剥夺，进程获得的资源，在未使用完之前，不能被剥夺，只能在完成时由自己释放
    * 循环等待，在发生死锁时，必然存在一个进程-资源的封闭的环形链
    
* 处理死锁的基本方法

    * 预防
    * 忽略
    * 避免
    * 检测解除

* 安全状态

    * 安全序列，一个进程序列安全的，如果对于每一个进程Pi,它需要的资源量不超过系统当前剩余资源量与所有进程当前占有资源量之和
    * 安全状态，存在安全序列的系统状态

* 不安全状态

    ```
    不安全状态： 系统中不存在安全序列
    
    安全状态=> 无死锁 死锁 => 不安全状态
    
    不安全状态不一定会造成死锁
    ```
* 死锁检测

    如果一个系统既不采用死锁预防算法也不采用死锁避免算法，那么可能会出现死锁，因此：
        
    * 用来检查系统状态是否出现死锁的检测算法
    * 从死锁状态中恢复的方法

    ```
    利用资源分配图的简化来进行死锁的检测
    
    简化规则
        - 若已分配和申请能满足需求，则删除边，使其成为孤立点-> 运行完毕后资源释放

    在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立节点，则称该图是可完全简化的，繁殖不可完全简化
    
    死锁定理
        - 死锁状态的充要条件：资源分配图不可完全简化
    ```

* 死锁的接触

    * 撤销进程

        * 终止所有的死锁进程
        * 一次终止一个进程指导取消死锁循环
    
    * 选择原则

        * 已消耗CPU时间最少
        * 到目前为止产生的输出量最少
        * 预计剩余的时间最擦好难过
        * 目前为止分配的资源总量最少
        * 优先级最低

