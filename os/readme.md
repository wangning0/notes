# 操作系统

> 操作系统是一组控制和管理计算机硬件和软件资源，合理的对各类作业进行调度以及方便用户使用的程序的集合


**操作系统的基本特征**
并发是最重要的特征，其他特征基本都以并发为前提

* 并发

    ```
    并行性是指两个或多个事件在同一时刻发生
    并发性是指两个或多个事件在同一时间间隔发生
    
    任务共行，从微观上来说
        单处理系统中的任务并发
        多处理系统中的任务并行
    ```    
    
* 共享

    ```
    系统中的资源可供内存中多个并发执行的进程共同使用
    临界资源： 在一段时间内只允许一个进程访问的资源
    互斥共享方式： 系统中的临界资源可以提供给多个进程使用，但一次仅能允许一个进程使用
    
    同时访问方式，从微观上来说，资源共享是指多个任务互斥地使用系统中的某个资源(如磁盘)
    ```
* 虚拟

    ```
    通过某种技术把一个物理实体变味若干个逻辑上的对应物
    虚拟处理机：分时实现
    虚拟设备：SPOOLING技术
    虚拟存储器：虚拟存储管理实现
    ```
* 不确定性

    ```
    同样的程序，同样的输入，未必同样的输出
    异步性： 是指进程已异步的方式执行，进程是已不可预知的速度向前推进
    ```
    
**进程**
    
* 进程控制

     ```
     进程控制的主要功能是为作业创建进程、撤销已结束的进程以及控制进程在运行过程中的状态转换
     ```
* 进程同步
    
    ```
    进程同步的主要任务是为了多个进程的运行进行协调
    两种方式：
        - 进程互斥方式，这是指进（线）程在对临界资源进行访问时
        - 进程同步方式，指进程相互合作完成共同的任务时，进程之间的协调
    ```
        
* 进程通信（IPC） 
* 调度

    ```
    在OS中作业／进程需要调度后才能执行完成
    ```
    
**内存**

* 内存分配

    ```
    分配方式：
        - 静态分配
        - 动态分配
    ```
* 内存保护

    ```
    首要任务是确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰
    
    内部保护机制：设置两个界限寄存器，越界检查由硬件实现
    
    ```
* 地址映射

    ```
    地址空间：目标程序或装入程序限定的空间，称为“地址空间”
    内存空间：由内存中的一系列但愿所限定的地址范围称为“内存空间”，其中的地址称为物理地址
    地址映射：运行时，将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址，称为地址映射
    ```
* 内存扩充

    ```
    虚拟内存技术
    
    内存扩充机制：
        - 请求调入功能，程序运行过程中，若所需的程序和数据尚未装入内存，可由OS从磁盘中将所需部分掉入内存，继续运行
        - 置换功能，将内存中的一部分暂时不用的程序和数据调出道磁盘上，然后再将所需掉入的部分装入内存
    ```

## 进程管理

* 进程

    ```
    一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程，进程描述了动态执行过程
    
    进程的特征：
        - 动态性
        - 独立性
        - 并发性
        - 异步性
        - 结构化 （进程=代码段+数据段+PCB）
    ```
* 进程是动态的，程序是静态的，程序是有序代码的集合，进程是暂时的，程序是永久的，进程是一个状态变化的过程，程序可长久保存，进程的组成包括程序，数据和PCB，进程是资源申请和系统调度的基本单位
* 进程的特征和状态

    ```
    进程的三种基本状态：
        - 就绪态(ready) 一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态，当调度給其CPU时，立即可以运行，位于就绪队列中
        - 执行态(running) 进程占有了包括CPU在内的全部资源，并在CPU上运行
        - 等待态/阻塞态(waiting/bolcked) 进程因等待某种事件的发生而暂时不能运行的状态，即使CPU空闲，该进程也不可运行，位于等待队列中
    ```
    ![](https://github.com/wangning0/notes/blob/master/os/images/1.png)
    
    ```
    五状态：
        - 新建状态 
            - os已完成为创建一进程所必要的工作
                - 构造了进程标志符
            - 但还没有允许执行该进程
                - os所需的关于该进程的信息保存在主存的进程表中，单进程自身还没有进入主存，也没有为这个程序相关的数据分配空间，程序留在辅存中
        - 退出状态
            - 不再有执行资格
            - 表格和其他信息暂时由辅助程序保留
        - 就绪态
        - 执行态
        - 阻塞态
    ```
    
    ```
    交换：
        - 挂起 把一个进程从内存转到外存
        - 激活 把一个进程从外村转到内存
    交换时I／O操作，费时间
    ```
    
    ![](https://github.com/wangning0/notes/blob/master/os/images/2.png)
    
    ```
    双挂起
        - 就绪 进程在内存且可立即进入运行状态
        - 阻塞 进程在内存，等待事件的出现
        - 阻塞／挂起 进程在外存  等待事件的出现
        - 就绪／挂起 进程在外存 但只要进入内存 即可执行
    ```
    
    ![](https://github.com/wangning0/notes/blob/master/os/images/3.png)


* 操作系统对进程的控制

    ```
    操作系统内核
        - 一些与硬件紧密相关的模块或运行频率很高的模块，公用基本操作模块等常驻内存，便于提高操作系统运行效能的软件

    内核的功能
        - 进程管理 创建、撤销、调度、控制
        - 存储管理 分配或回收空间、虚拟存储管理
        - I/O设备管理 设备、通道的分配和回收、设备的管理、虚拟设备的实现
        - 中断处理 操作系统的充要活动都依赖于中断
    ```
    
* 进程控制块

    |PCB  | | 
    | :--  |  :--  | 
    | pid  | 进程标志符 |
    |  进程状态 | 指明进程当前的状态 |
    |  现场    | |
    |  优先级    | 进程优先级 |
    | 阻塞原因     | 由执行状态转变成阻塞状态所等待发生的事件 |
    |  程序地址    | 进程的程序和数据所在的内存或外村地址 |
    |  同步机制    | 实现进程同步和进程通信时必须的机制 | 
    | 资源清单    | 进程所需的全部资源以及分配到该进程的资源的清单 |
    | 链接指针  | |

* 进程控制块的组织方式
    
    * 链接方式
    * 索引方式

* 进程组织

    ```
    进程树
        - 描述了进程的家族关系
        - 子进程可继承父进程的资源
        - 父进程的撤销会撤销全部子进程
        - 根进程
        - 孤儿进程的托管
    ```
    
* 进程的创建

    * 用户登录
    * 作业调度
    * 提供服务
    * 应用请求

    ```
    进程的创建
        - 申请空白PCB
        - 为新进程分配资源（内存、文件等）
        - 初始化PCB数据结构
        - 将新进程插入就绪队列

    创建新进程后
        - 父进程与子进程并发执行
        - 父进程等待，直到某个或者全部子进程执行完毕

    ```
    
* 进程控制函数

    ```
    fork  创建新进程
        - 在调用fork之后，父子进程俊仔下一条语句上继续执行
        - 子进程中返回的pid为0
        - 父进程中返回的pid是创建的子进程pid
    ```
    
    ```
    fork（）两个关键点
        - 运行顺序
            - 父子进程的运行是无关的，运行顺序不固定
            - 若要求父子进程运行顺序一定，要用到IPC
        - 数据共享
            - 出了子进程标志符合PCB结构中的某些参数不同，子进程是父进程的精确复制
    ```
    
    ```
    exec() 执行一个文件的调用
        - 通过exec() 调用族，加载新的程序文件
        - 子进程可拥有自己的可执行代码，即用一个新进程覆盖调用进程
        - 在大多数程序中，系统调用fork和exec是结合在一起的，父进程生成一个子进程，然后通过调用exec覆盖该子进程
    ```
* 进程的终止

    ```
    引起进程终止的事件
        - 正常结束 exit halt logoff
        - 异常结束
            - 无可用存储器
            - 越界
            - 保护错误
            - 算术错误
            - I/O失败
            - 无效指令
            - 特权指令
        - 外界干预
            - kill进程
            - 父进程终止
            - 父进程请求

    进程的终止过程
        - 检索PCB，检查进程状态
        - 执行态 ===> 终止
        - 有无子孙需终止
        - 归还资源给父进程／系统
        - 从PCB队列中移出PCB
    ```
* 进程的两个特点

    * 资源所有权，一个进程包括一个保存进程映像的虚地址空间，并且不时地被分配给对资源的控制或所有权
    * 调度／执行，一个具有执行状态和调度优先级的进程是一个被操作系统调度并分发的实体

    ```
    为了区分这两个特点，调度并分发派的部门被称为线程／轻量级进程，而资源所有权被称为进程
    ```

* 线程的优势

    * 减少并发执行时的时空开销
    * 线程是系统独立调度的基本单位，基本不拥有系统资源，只有少量资源(PC 寄存器 栈),共享其所属进程所拥有的全部资源

* 进程与线程

    ![](https://github.com/wangning0/notes/blob/master/os/images/4.png)
    
* 线程状态

    * 执行状态、阻塞状态、就绪状态
    * 在线程切换时保存的线程信息

        * 一个执行栈
        * 每个线程静态存储局部变量
        * 对存储器和其进程资源的访问
    * 派生， 当产生一个新进程时，同时也为该进程派生了一个线程，随后可以在同一个进程中派生另一个线程，新线程放在就绪队列中
    * 结束，线程完成时，其寄存器信息和栈都被释放
    * 就绪
    * 运行
    * 阻塞，当线程需要等待一个事件时，他将阻塞，处理器转而执行另一个就绪线程

* 线程分类

    * 内核级线程，每个线程在内核看来都是一个进程

        ```
        内核级线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，其创建、撤销和切换等都是依靠内核实现
        内核为每一个内核线程设置了一个线程控制块，根据该控制块感知线程的存在，加以控制
        ```
    * 用户级线程，内核无法感知，用户自己控制

        ```
        用户级线程的创建、撤销、线程之间的同步与通信等功能，都无须利用系统调用来实现
        用户级线程的切换，速度快，不需要内核的支持
        线程控制块设置在用户空间，节省系统开销
        当引起进程阻塞时，会削弱进程中的线程的并发性
        ```
    ```
    内核线程和用户线程不同：
        - 调度开销前者大，相当于进程切换
        - 并发效率，用户线程某一个线程阻塞，由于内核不知道这些进程的存在，因此将进程阻塞，内核线程中某一个线程阻塞，则阻塞改线程，进程仍可运行
        - 执行时间，用户级线程以进程为单位平均分配时间，对线程间并发执行不利，内核级线程以线程为单位分配时间
    ```

## 处理机调度

> 处理机是最重要的计算机资源，提高处理机的利用率及改善系统性能(吞吐量、响应时间),在很大程度上取决于进程调度性能的好坏

* 调度的目标

    * 提高处理机的利用率
    * 提高系统吞吐量
    * 尽量减少进程的响应时间
    * 防止进程长期得不到运行

* 调度的方式

    ```
    低级调度
        - 短程调度
        - 进程调度
    中级调度 为提高系统吞吐量和内存利用率而引入的内外存交换功能
        - 中程调度
    高级调度  将外存作业掉入内存，创建PCB等，插入就绪队列
        - 长程调度
        - 作业调度
        - 接纳调度
    ```
* 进程调度算法基本类型

    * 非抢占 就绪进程不可以从运行进程中抢占CPU

        ```
        一旦进程处于运行状态，直到终止或者阻塞，才释放CPU
        ```
    * 抢占 就绪进程可以从运行进程中抢占CPU

        ```
        允许调度程序根据某种策略暂停当前运行的进程，将其转移到就绪状态，并选择另一个进程执行
        新进程到达时，中断的发生，阻塞进程置为就绪态
        ```
* 调度的原则

    * 面向用户的原则

        * 周转时间
        * 响应时间
        * 截止时间
        * 优先级
    
    * 面向系统的原则

        * 吞吐量
        * 利用率
        * 公平性
        * 优先级

* 调度算法

    * 先来先服务 FCFS
    
        ```
        当每个进程就绪后，它加入就绪队列(队尾)
        当正在运行的进程停止执行时，选择在就绪队列中存在时间最长的进程运行(队首)
        
        评价
        非抢占调度
        对长进程有利，不利于短进程
        适合CPU繁忙型进程，不适合I/O繁忙型进程
        不能直接用于分时系统
        和其他调度算法综合使用
        ```
    * 最短作业优先 SJF

        ```
        非剥夺，当前进程结束后，选择所需处理时间最短的进程
        如果两个进程剩余时间相同，则使用FCFS来调度
        
        评价
            - 有利于短进程，提高了平均周转时间
            - 长进程可能被饿死
            - 需要知道或估计每个进程的处理时间
        ```

    * 轮转调度RR(Round Robin)

        ```
        时间片调度： 以一定的时间间隔周期性产生时钟中断，当前正在运行的进程被置于就绪队列尾，然后基于FCFS选择下一个就绪进程运行
        
        时间片的长度从几ms~几百ms
        
        时间片长度变化影响较大
            - 过长，退化成FCFS
            - 过短，用户的一次请求需要多个时间片才能处理完，上下文切换次数增加
        ```
        
    * 最短剩余时间调度SRT

        ```
        原理
            - 对SJF增加了剥夺机制
            - 选择预期剩余时间最短的进程，当一个新进程加入就绪队列时，他肯呢个比当前运行的进程具有更短的剩余时间
        ```
    * 基于优先级的调度算法

        ```
        每个进程都有一个优先级，调度程序选择具有较高优先级的进程
        ```
    * 高响应比优先算法(HRRN)

        ```
        非抢占式
        响应比R = 周转时间／服务时间 = （等待时间+服务时间）／服务时间
        ```
        
    * 多级队列调度算法，将就绪队列分为多个独立队列，进程所属的队列固定，通过对各队列的区别对待，达到一个综合的调度目标

## 进程并发控制： 互斥与同步

* 进程间的制约关系

    * 间接制约 资源共享 -> 互斥
    * 直接制约 进程合作 -> 同步

* 临界资源，一次只允许一个进程访问的资源
* 临界区， 进程中访问临界资源的代码段
* 同步的解决策略

    * 软件
    * 硬件
    * 信号量

        ```
        多进程通过信号传递协调工作，根据信号指示停止执行或者向前推进
        
        信号： 信号量(s)
        
        原语
            - wait(s) 等待信号，并占有资源
            - signal(s) 释放资源，并激发信号
        ```
    * 管程
    * 消息传递

## 进程并发控制： 信号量的应用

* 信号量类型

    * 资源信号量
    * 互斥信号量

* PV操作，P表示通过的意思，V表示释放的意思
* 读者／写者问题

    ```
    三个角色
        - 一个共享的数据去
        - Reader 制度去这个数据区的进程
        - Writer 只往数据区中写数据的进程
    三个条件
        - 多个Reader 可同时读数据区
        - 一次只有一个Writer可以往数据区写
        - 数据区不允许同时读写

    读者优先
        如有读者正在读数据，则允许多个读者同时进入读数据，只有所有读者退出，在允许写者进入写数据
    
    写者优先
        如果写者正在写，那么后续的写者申请优先于心的读者进入
    ```
    
## 进程间通信

> IPC 是指进程之间的信息交换

* 进程通信分为两类

    * 低级通信： 以信号量为通信工具，交换的信息量少
    * 高级通信：操作系统所提供的一组通信命令，高效地传送大量数据
    
        ```
        共享存储
        消息传递／消息队列
        管道
        套接字
        信号
        内存映射文件
        ```
## 死锁

> 多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，他们都将无法向前推进

* 产生死锁的原因

    * 资源不足导致的资源竞争
    * 并发执行的顺序不当

* 死锁的充要条件

    * 互斥,进程对所分配到的资源进行排他性使用
    * 占有且等待，进程已经占有了至少一个资源，又提出了新的资源要求，且该资源被其他进程占有
    * 非剥夺，进程获得的资源，在未使用完之前，不能被剥夺，只能在完成时由自己释放
    * 循环等待，在发生死锁时，必然存在一个进程-资源的封闭的环形链
    
* 处理死锁的基本方法

    * 预防
    * 忽略
    * 避免
    * 检测解除

* 安全状态

    * 安全序列，一个进程序列安全的，如果对于每一个进程Pi,它需要的资源量不超过系统当前剩余资源量与所有进程当前占有资源量之和
    * 安全状态，存在安全序列的系统状态

* 不安全状态

    ```
    不安全状态： 系统中不存在安全序列
    
    安全状态=> 无死锁 死锁 => 不安全状态
    
    不安全状态不一定会造成死锁
    ```
* 死锁检测

    如果一个系统既不采用死锁预防算法也不采用死锁避免算法，那么可能会出现死锁，因此：
        
    * 用来检查系统状态是否出现死锁的检测算法
    * 从死锁状态中恢复的方法

    ```
    利用资源分配图的简化来进行死锁的检测
    
    简化规则
        - 若已分配和申请能满足需求，则删除边，使其成为孤立点-> 运行完毕后资源释放

    在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立节点，则称该图是可完全简化的，繁殖不可完全简化
    
    死锁定理
        - 死锁状态的充要条件：资源分配图不可完全简化
    ```

* 死锁的接触

    * 撤销进程

        * 终止所有的死锁进程
        * 一次终止一个进程指导取消死锁循环
    
    * 选择原则

        * 已消耗CPU时间最少
        * 到目前为止产生的输出量最少
        * 预计剩余的时间最擦好难过
        * 目前为止分配的资源总量最少
        * 优先级最低

## 存储管理

> 主要是指对内存储器的管理

* 概述

    ```
    在多道程序环境中，存储管理的主要目的：
        - 提高资源的利用率，尽量满足多个用户对内存的要求
        - 方便用户使用内存，使用户不必考虑作业具体放在内存哪块区域
     实现的功能：
        - 分配和回收
        - 共享
        - 保护
        - 扩充
    ```
* 存储系统的结构

    ![](https://github.com/wangning0/notes/blob/master/os/images/5.png)

* 程序的诞生

    * 预处理
    * 编译
    * 汇编
    * 链接
    * 加载
    
* 空间分类

    * 名空间
    
        用汇编语言或高级语言编写程序时，用符号名来访问某一单元，程序中由符号名组成的程序空间成为符号名空间
        
    * 逻辑空间

        源程序经过编译形成目标程序，每个目标程序都以0为基址顺序进行编址，原来用符号名访问的单元用具体的数据--单元号取代，这样生成的目标程序占据一定的地址空间，成为逻辑地址空间，成为逻辑空间
        
    * 内存空间(物理空间)

        内存由若干存储单元组成，每个存储单元有一个编号，这种编号可唯一标识一个存储单元，称为内存地址
        内存地址的集合称为内存地址空间
        
    * 地址映射

        将逻辑地址转换为运行时机器直接寻址的物理地址
        
    ![](https://github.com/wangning0/notes/blob/master/os/images/6.png)


    * 程序的链接

        源程序经过编译后，可得到一组目标模块，在利用链接程序将目标模块链接形成装入模块
        
        链接分为三种：
        
        * 静态链接

            在编译链接阶段，将各目标模块及它们所需的库函数，链接成一个完整的装入密快，以后不再拆开
            
            * 相对地址的修改
            * 变换外部调用符号
            
        * 动态链接

            * 装入时动态链接

                目标模块在装入内存时，采用边装入边链接的链接方式，装入后不再链接，便于目标模块的共享
                * 静态链接，每个装入模块都还有其目标模块的拷贝，无法实现对目标模块的共享
                * 动态链接，OS可将一个目标模块链接到多个装入模块上，实现多个应用程序对该模块的共享
            * 运行时动态链接

                在程序执行中需要该目标时，由OS找到该模块，将它装入内存，链接到调用者模块上
                
                执行过程中没用到的目标模块，不会装入和链接到模块中，节省内存空间，共享和程序的装入
                
## 存储器管理：连续分配

* 存储分配管理方式

    * 连续分配

        * 单一连续分配

            ```
            整个内存空间分成系统区和用户区，系统区給操作系统使用，用户区給用户使用
            用户区分配给一个进程
            ```
        * 分区管理
            
            ```
            把内存分为一些大小相等或不等的分区
            每个应用进程占用一个或几个分区，操作系统占用其中一个分区
            
            适用于多道程序系统和分时系统
            
            内部碎片 是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间
            外部碎片 指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域
            难以进行内存分区的共享
            
            数据结构
                - 分区表
                - 记录空闲分区和占用分区
                - 表项数目随着内存的分配和释放而送台改变
                - 空闲分配表根据分配算法组织表项
            ```
            
            * 固定分区分配

                ```
                分区的划分一般由系统管理员或操作系统决定，一旦划定，整个执行过程中分区不变
                
                难以仅从内存分区的共享
                碎片
                ```
            * 动态分区分配

                ```
                动态创建分区：
                    在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小
                    
                    没有内部碎片
                    
                    外部碎片
                    
                    常用分区分配算法
                    
                        - 最先适配算法， 按分区先后次序，从头查找，找到符合要求的第一个分区,缺点是在低地址部分很快集中了许多非常小的空白区，因而在空白区分配时，搜索次数增加，影响工作效率
                        - 循环最先适配算法,按分区先后次序，从上次分配的分区起查找(到最后分区时再回到开头),找到符合要求的第一个分区
                        - 最佳适配算法，在所有大等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。能使碎片尽量小
                        - 最坏适配算法，分区时取所有空闲区中最大的一块，必要时摘分成，从而使链表中的节点大小趋于均匀
                ```
                
            * 可重定位分区分配

                ![](https://github.com/wangning0/notes/blob/master/os/images/8.png)
                在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址（逻辑地址），将相对地址转换为物理地址的工作，被推迟到程序指令
要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即需在系统中增设一个重定位寄存器，用来存放
程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的

        * 覆盖

            ```
            目标：在较小的可用内存中运行较大的程序
            原理：任何时刻只在内存中保留必须的指令和数据，当需要其他指令数据时，将其装入到暂时不需要的指令数据所占用的内存空间
            ```
        * 对换

    * 离散分配

        * 分页存储管理
        * 段式存储管理
        * 段页式存储管理

    * 虚拟存储器

        * 请求分页存储管理
        * 请求分段存储管理
        * 段页式虚拟存储
        
        
    * 伙伴系统(Buddy System)

        伙伴系统的宗旨就是用最小的内存块来满足内核的对于内存的请求
        
        申请时对半拆分，指导能够容纳申请量，空闲的放入新队列
        
        释放回收时合并，尺寸相同
        
        ![](https://github.com/wangning0/notes/blob/master/os/images/7.png)

    * 常用分区分配算法

        * 碎片问题，经过一段时间分配、回收后，内存中存在很多很小的空闲块，每个都很小，不足以满足分配要求，单其总和满足分配要求 会造成存储资源浪费
        * 解决方法：
        
            * 紧凑技术
            * 离散分配方式

    * 分页存储管理

        * 用户空间划分
           - 用户程序按逻辑页划分成大小相等的部分，称为页
           - 从-开始编制页号，页内地址相对于0编址
           - 逻辑空间划分由系统自动完成，对用户透明
           - 一般页大小为2的整数幂，因此地址的高位部分为页号，低位部分为页内地址

       * 分页逻辑地址结构
           - 页内地址： 长度由页大小决定
           - 页号：除去页内地址所占的最高位部分
           - 逻辑地址为32位，页大小为4KB，则逻辑地址的低12位，为页内地址w，而高20位为页号p

       * 基本页式存储管理
           - 内存空间划分
               - 按页的大小划分为大小相等的区域，称为内存块 -> frame
               - 从0开始编号
           - 内存分配
               - 以页为单位进行分配
               - 逻辑上相邻的页，物理上不一定相邻，反之亦然
           
       * 地址变换机构
           - 页表 (page table)，逻辑页号 -> 物理块号的映射
                
            ![](https://github.com/wangning0/notes/blob/master/os/images/9.png)
                
           - 基本地址变换机构
           - 每个进程都有一个页表，其信息放在PCB中，执行时将首地址装入页表寄存器
           - 页表放在内存，属于进程的现场信息
    
        * 存储保护

            * 信息保护可以从两方面实现

                * 进行地址变换时，产生的页号应小于页表长度，否则视为越界访问
                * 在页表中增加存取控制和存储保护的信息，对每一个存储快，允许四种保护方式

                    * 禁止做任何操作
                    * 只执行
                    * 只读
                    * 可读可写

            
## 设备管理
    
* I/O控制方式

    * 程序I/O控制方式

        早期的计算机系统走，无中断结构，处理机对I/O设备的控制采取I/O方式，忙-等待方式
        
    * 中断方式

        中断驱动I/O控制方式
        
        * 现代计算机系统中，都引入了中断机构，对I/O设备的控制，广泛采用中断驱动方式
        * CPU=>设备控制器发出I/O命令，立即返回继续执行原来的任务
        * 设备控制器按照该命令的要求控制制定设备，刺齿，CPU和I/O设备并行操作
        * 一旦设备操作完成，控制器便通过控制线向CPU发送中断信号
        * CPU向控制器发送取走数据的信号，然后再通过控制器和数据线将数据写入内存指定单元
    * 直接存储器访问
    
        ![](https://github.com/wangning0/notes/blob/master/os/images/10.png)
        
        * DMA控制器由三部分组成

            * 主机与DMA控制器的接口
            * DMA控制器与块设备的接口
            * I/O控制逻辑

        ![](https://github.com/wangning0/notes/blob/master/os/images/10.png)
        
        * 关键寄存器

            * 命令/状态寄存器(CR),接收从CPU发来的I/O命令，或有关控制信息，或设备的状态
            * 内存地址寄存器(MAR),数据在内存的起始地址
            * 数据寄存器(DR),暂存从设备到内存，或是内存到设备的数据
            * 数据计数器(DC),存放本次CPU要读或写的字节数
        
        ![](https://github.com/wangning0/notes/blob/master/os/images/12.png)
        
* 缓冲管理

    * 缓和CPU与I/O设备间速度不匹配的矛盾

        例如一个程序，它时而进行长时间的计算而没有输出，时而又阵发性把输出送到打印机。由于打印机的速度跟不上CPU，而使得CPU长时间的等待。如果设置了缓冲区，程序输出的数据先送到缓冲区暂存，然后由打印机慢慢地输出。这时，CPU不必等待，可以继续执行程序。实现了CPU与I/O设备之间的并行工作。事实上，凡在数据的到达速率与其离去速率不同的地方，都可设置缓冲，以缓和它们之间速度不匹配的矛盾。众所周知，通常的程序都是时而计算，时而输出的
        
    * 减少对CPU的中断频率

        如果I/O操作每传送一个字节就要产生一次中断，那么设置了n个字节的缓冲区后，则可以等到缓冲区满才产生中断，这样中断次数就减少到1/n，而且中断响应的时间也可以相应的放宽
        
    * 提高CPU和I/O设备之间的并行性

        缓冲的引入可显著提高 CPU和设备的并行操作程度，提高系统的吞吐量和设备的利用率。

* 缓冲类型

    * 单缓冲

        ![](https://github.com/wangning0/notes/blob/master/os/images/13.png)
        
    * 多缓冲

        ![](https://github.com/wangning0/notes/blob/master/os/images/14.png)
        
    * 循环缓冲
    * 缓冲池

* 设备独立性

    设备无关性，应用程序独立于具体使用的物理设备，
    
* SPOOLing

    外部设备联机并行操作，它是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”
    
    * 组成
        
        * 输入输出进程
        * 输入输出井
        * 输入输出缓冲

    ![](https://github.com/wangning0/notes/blob/master/os/images/15.png)
    
    * 特点

        * 提高I/O速度
        * 将独占设备改造为共享设备
        * 实现了虚拟设备功能

    * 设备管理：调度与实例

        ![](https://github.com/wangning0/notes/blob/master/os/images/16.png)
        
        * 磁盘存储器

            * 包括一或多个物理盘片，每个磁盘片分一个或两个存储面
            * 每个磁盘面被组织成若干个同心环，这种环称为磁道
            * 每条磁道逻辑上划分成若干个扇区
            * 不同盘面形同的磁道成为柱面

        * 磁盘结构

            * 磁盘驱动器采用线性逻辑块编址
            * 逻辑块是最小传输单位(512B)
            * 线性逻辑块号一一映射到扇区

                * 扇区0，最外层柱面的第一个磁道的第一个扇区
                * 排序规则，按同磁道=>同柱面其他磁道=>其他柱面的顺序对扇区排序

        * 访问模式

            * 直接(随机)存取：存取磁盘上任一物理块，不依赖于该物理块所处的位置

                * 固定头磁盘 每个磁道设置一个刺头，变换磁道时不需要磁头的机械移动，速度快成本高
                * 移动头磁盘，一个盘面只有一个磁头，变换磁道时需要移动磁头，速度慢成本低

            * 顺序存取：只有在前面的物理块被访问过之后，才能存取后续的物理块的内容

        * 磁盘访问时间

            * 寻道时间 
            * 传输时间
            * 延迟时间

        * 磁盘中的连续存储，是通过同一柱面
        * 磁盘调度

            * 先来先服务

                ```
                根据进程请求访问磁盘的先后次序进行调度
                公平、简单
                
                未对寻道进行优化，平均寻道时间较长
                ```
            * 最短寻道时间优先 SSTF

                ```
                优先调度与当前磁头所在的磁道距离最近的请求
                ```
            * 扫描算法
            * Look & C-Look算法

        * 磁盘缓存

            * 利用内存中的存储空间来暂存从磁盘中一系列盘块的信息
            * Linux文件系统缓存

## 文件管理

